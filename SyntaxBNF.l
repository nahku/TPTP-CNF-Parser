
%{
//-----------------------------------------------------------------------------
#include <string.h>
#include <stdlib.h>
#include "y.tab.h"
//-----------------------------------------------------------------------------
//----Compile with -DP_VERBOSE=2 to list tokens as they are seen.
#ifndef P_VERBOSE
#  define P_VERBOSE 0
#  endif
int verbose2 = P_VERBOSE;

//----If tptp_prev_tok == PERIOD, you are outside any sentence.
#ifndef PERIOD
#  define PERIOD 46
#  endif

#define TPTP_STORE_SIZE 32768

//----These have to be external as they are references from other code that
//----is generated by lex/yacc.
int tptp_prev_tok = PERIOD;
int tptp_store_size = TPTP_STORE_SIZE;
char* tptp_lval[TPTP_STORE_SIZE];
//-----------------------------------------------------------------------------
void tptp_print_tok(char* lval) { 

    printf("%3d:%s;\n", tptp_prev_tok, lval);

    return; 
}
//-----------------------------------------------------------------------------
int tptp_update_lval(char* lval) { 

    static int tptp_next_store = 0;
    int next = tptp_next_store;

    free(tptp_lval[tptp_next_store]);
    tptp_lval[tptp_next_store] = strdup(lval);
    tptp_next_store = (tptp_next_store+1) % TPTP_STORE_SIZE;
    if (verbose2 == 2) {
        tptp_print_tok(lval);
    }

    return next; 
}
//-----------------------------------------------------------------------------
//----%Start: INITIAL begin sentence, B before formula. No others.
%}

single_quoted         {single_quote}{sq_char}{sq_char}*{single_quote}
distinct_object       {double_quote}{do_char}*{double_quote}
dollar_word           {dollar}{lower_word}
dollar_dollar_word    {dollar}{dollar}{lower_word}
upper_word            {upper_alpha}{alpha_numeric}*
lower_word            {lower_alpha}{alpha_numeric}*
vline                 [|]
real                  ({signed_real}|{unsigned_real})
signed_real           {sign}{unsigned_real}
unsigned_real         ({decimal_fraction}|{decimal_exponent})
rational              ({signed_rational}|{unsigned_rational})
signed_rational       {sign}{unsigned_rational}
unsigned_rational     {decimal}{slash}{positive_decimal}
integer               ({signed_integer}|{unsigned_integer})
signed_integer        {sign}{unsigned_integer}
unsigned_integer      {decimal}
decimal               ({zero_numeric}|{positive_decimal})
positive_decimal      {non_zero_numeric}{numeric}*
decimal_exponent      ({decimal}|{decimal_fraction}){exponent}{exp_integer}
decimal_fraction      {decimal}{dot_decimal}
dot_decimal           {dot}{numeric}{numeric}*
exp_integer           ({signed_exp_integer}|{unsigned_exp_integer})
signed_exp_integer    {sign}{unsigned_exp_integer}
unsigned_exp_integer  {numeric}{numeric}*
double_quote          ["]
do_char               ([\40-\41\43-\133\135-\176]|[\\]["\\])
single_quote          [']
sq_char               ([\40-\46\50-\133\135-\176]|[\\]['\\])
sign                  [+-]
dot                   [.]
exponent              [Ee]
slash                 [/]
zero_numeric          [0]
non_zero_numeric      [1-9]
numeric               [0-9]
lower_alpha           [a-z]
upper_alpha           [A-Z]
alpha_numeric         ({lower_alpha}|{upper_alpha}|{numeric}|[_])
dollar                [$]
comment               {comment_line} | {comment_block}
comment_line          [%]{printable_char}*
comment_block         [/][*]{not_star_slash}[*][*]*[/]
not_star_slash        ([^*]*[*][*]*[^/*])*[^*]*
printable_char        .

%Start B FF SQ1 SQ2 Q1 Q2
%%

"," {
    tptp_prev_tok=COMMA;
    yylval.ival = tptp_update_lval(yytext);
    return(COMMA);
}
"=" {
    tptp_prev_tok=EQUALS;
    yylval.ival = tptp_update_lval(yytext);
    return(EQUALS);
}
"!=" {
    tptp_prev_tok=EXCLAMATION_EQUALS;
    yylval.ival = tptp_update_lval(yytext);
    return(EXCLAMATION_EQUALS);
}
"[" {
    tptp_prev_tok=LBRKT;
    yylval.ival = tptp_update_lval(yytext);
    return(LBRKT);
}
"(" {
    tptp_prev_tok=LPAREN;
    yylval.ival = tptp_update_lval(yytext);
    return(LPAREN);
}
"." {
    BEGIN INITIAL;
    tptp_prev_tok=PERIOD;
    yylval.ival = tptp_update_lval(yytext);
    return(PERIOD);
}
"]" {
    tptp_prev_tok=RBRKT;
    yylval.ival = tptp_update_lval(yytext);
    return(RBRKT);
}
")" {
    tptp_prev_tok=RPAREN;
    yylval.ival = tptp_update_lval(yytext);
    return(RPAREN);
}
"~" {
    tptp_prev_tok=TILDE;
    yylval.ival = tptp_update_lval(yytext);
    return(TILDE);
}
"|" {
    tptp_prev_tok=VLINE;
    yylval.ival = tptp_update_lval(yytext);
    return(VLINE);
}
<INITIAL>"cnf" {
    BEGIN B;
    tptp_prev_tok=_LIT_cnf;
    yylval.ival = tptp_update_lval(yytext);
    return(_LIT_cnf);
}
<INITIAL>"include" {
    BEGIN B;
    tptp_prev_tok=_LIT_include;
    yylval.ival = tptp_update_lval(yytext);
    return(_LIT_include);
}

{single_quoted} {
    tptp_prev_tok=single_quoted;
    yylval.ival = tptp_update_lval(yytext);
    return(single_quoted);
}
{distinct_object} {
    tptp_prev_tok=distinct_object;
    yylval.ival = tptp_update_lval(yytext);
    return(distinct_object);
}
{dollar_word} {
    tptp_prev_tok=dollar_word;
    yylval.ival = tptp_update_lval(yytext);
    return(dollar_word);
}
{dollar_dollar_word} {
    tptp_prev_tok=dollar_dollar_word;
    yylval.ival = tptp_update_lval(yytext);
    return(dollar_dollar_word);
}
{upper_word} {
    tptp_prev_tok=upper_word;
    yylval.ival = tptp_update_lval(yytext);
    return(upper_word);
}
{lower_word} {
    tptp_prev_tok=lower_word;
    yylval.ival = tptp_update_lval(yytext);
    return(lower_word);
}
{vline} {
    tptp_prev_tok=vline;
    yylval.ival = tptp_update_lval(yytext);
    return(vline);
}
{real} {
    tptp_prev_tok=real;
    yylval.ival = tptp_update_lval(yytext);
    return(real);
}
{signed_real} {
    tptp_prev_tok=signed_real;
    yylval.ival = tptp_update_lval(yytext);
    return(signed_real);
}
{unsigned_real} {
    tptp_prev_tok=unsigned_real;
    yylval.ival = tptp_update_lval(yytext);
    return(unsigned_real);
}
{rational} {
    tptp_prev_tok=rational;
    yylval.ival = tptp_update_lval(yytext);
    return(rational);
}
{signed_rational} {
    tptp_prev_tok=signed_rational;
    yylval.ival = tptp_update_lval(yytext);
    return(signed_rational);
}
{unsigned_rational} {
    tptp_prev_tok=unsigned_rational;
    yylval.ival = tptp_update_lval(yytext);
    return(unsigned_rational);
}
{integer} {
    tptp_prev_tok=integer;
    yylval.ival = tptp_update_lval(yytext);
    return(integer);
}
{signed_integer} {
    tptp_prev_tok=signed_integer;
    yylval.ival = tptp_update_lval(yytext);
    return(signed_integer);
}
{unsigned_integer} {
    tptp_prev_tok=unsigned_integer;
    yylval.ival = tptp_update_lval(yytext);
    return(unsigned_integer);
}
{decimal} {
    tptp_prev_tok=decimal;
    yylval.ival = tptp_update_lval(yytext);
    return(decimal);
}
{positive_decimal} {
    tptp_prev_tok=positive_decimal;
    yylval.ival = tptp_update_lval(yytext);
    return(positive_decimal);
}
{decimal_exponent} {
    tptp_prev_tok=decimal_exponent;
    yylval.ival = tptp_update_lval(yytext);
    return(decimal_exponent);
}
{decimal_fraction} {
    tptp_prev_tok=decimal_fraction;
    yylval.ival = tptp_update_lval(yytext);
    return(decimal_fraction);
}
{dot_decimal} {
    tptp_prev_tok=dot_decimal;
    yylval.ival = tptp_update_lval(yytext);
    return(dot_decimal);
}
{exp_integer} {
    tptp_prev_tok=exp_integer;
    yylval.ival = tptp_update_lval(yytext);
    return(exp_integer);
}
{signed_exp_integer} {
    tptp_prev_tok=signed_exp_integer;
    yylval.ival = tptp_update_lval(yytext);
    return(signed_exp_integer);
}
{unsigned_exp_integer} {
    tptp_prev_tok=unsigned_exp_integer;
    yylval.ival = tptp_update_lval(yytext);
    return(unsigned_exp_integer);
}
{comment}    tptp_update_lval(yytext);
[ \\t\\n]    ;
[\\000-\\040]|[\\177]    ;
[\\041-\\176]    return(unrecognized);
%%

